%%%%%%%%%%%%%%%%%%%%%%% file typeinst.tex %%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is the LaTeX source for the instructions to authors using
% the LaTeX document class 'llncs.cls' for contributions to
% the Lecture Notes in Computer Sciences series.
% http://www.springer.com/lncs       Springer Heidelberg 2006/05/04
%
% It may be used as a template for your own input - copy it
% to a new file with a new name and use it as the basis
% for your article.
%
% NB: the document class 'llncs' has its own and detailed documentation, see
% ftp://ftp.springer.de/data/pubftp/pub/tex/latex/llncs/latex2e/llncsdoc.pdf
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\documentclass[runningheads,a4paper]{llncs}

\usepackage[latin1]{inputenc}
\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{algorithm}% http://ctan.org/pkg/algorithms
\usepackage{algpseudocode}% http://ctan.org/pkg/algorithmicx
\usepackage{amsmath}
\usepackage{url}
\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\begin{document}

\mainmatter  % start of an individual contribution

% first the title is needed
\title{Un marco de aplicaciones para computación evolutiva voluntaria}

% a short form should be given in case it is too long for the running head
%\titlerunning{Lecture Notes in Computer Science: Authors' Instructions}

% the name(s) of the author(s) follow(s) next
%
\author{Israel Blancas \inst{1} \and J. J. Merelo \inst{1}}
%
%\authorrunning{La importancia de la computaci\'on voluntaria y un ejempl}
% (feature abused for this document to repeat the title also on left hand pages)

% the affiliations are given next; don't give your e-mail address
% unless you accept that it will be published

\institute{Departamento de Arquitectura y Tecnolog\'ia de Computadores,
Universidad de Granada, Espa\~na}

\maketitle


\begin{abstract}
% Tienes que adaptar el resumen al título - JJ 
La computación evolutiva es un tipo de computación distribuida que permite
realizar experimentos utilizando la potencia de cálculo proporcionada
por las máquinas de usuarios que deciden colaborar libremente en la investigación.
NodIO es un marco de desarrollo de aplicaciones para la creación de este
tipo de experimentos. A diferencia de otros frameworks que realizan las mismas
tareas, NodIO no necesita instalar nada en el lado del cliente, ya que se 
encuentra escrito en Javascript, por lo que solo será necesario
tener un navegador web o un intérprete. 
\end{abstract}


\begin{keywords}
  Computación voluntaria,  algoritmos evolutivos, computación distribuida,
  computación en internet, computación nube, evaluación de rendimiento
\end{keywords}

\section{Introducción}
% Tienes que explicar por qué hace falta computación voluntaria en computación evolutiva - JJ

Diversos son los métodos utilizados por los científicos
para el procesamiento de largos conjuntos de resultados obtenidos
a través de la elaboración de experimentos o, en su defecto, la propia
realización de los experimentos: uso de un único supercomputador para
todo el procesamiento; creación de un clúster de máquinas en un centro
de procesamiento (o cloud); o, como en el caso que nos ocupa, la computación voluntaria.

La computación voluntaria es un método de cómputo mediante el cual se
permite a distintos usuarios colaborar en un proyecto científico,
en muchas ocasiones, aprovechando el tiempo ocioso de sus máquinas. Esta colaboración
se produce entre computadores independientes, interconectados a través de una o varias redes
para comunicar información y coordinar sus tareas construyendo redes con potencias
equivalentes a la de los supercomputadores o, incluso, superiores.

En estos sistemas se desean características como: tolerancia a fallos -en caso que una de las
máquinas deje de hacer un trabajo, es conveniente que ese cómputo sea realizado por otro usuario-;
ejecución en múltiples máquinas -para obtener la potencia de cálculo necesaria-;
compatibilidad entre los dispositivos conectados -es necesario que la información
transmitida por los distintos dispositivos pueda entenderse por otros dispositivos del sistema-;
seguro -evitando que uno o más usuarios con malintencionados traten de realizar algún tipo de actividad 
nociva para el resto-; y, por último, escalabilidad -ya que lo que se busca es la participación 
del mayor número de usuarios posible, es necesario que el sistema sea escalable-.

La potencia computacional total del sistema variar\'a en funci\'on del n\'umero de
usuarios que decidan colaborar, as\'i como de la propia potencia de sus m\'aquinas
y la capacidad del nodo ``coordinador" sistema para repartir el trabajo
y recoger los resultados.

La computaci\'on voluntaria es importante, entre otras de las cuestiones ya expuestas,
porque permite que ciudadanos fuera del \'ambito de la investigaci\'on, puedan
tomar parte de la misma.

Adem\'as, gracias a que son los usuarios quienes ``prestan" sus m\'aquinas, el sistema
es m\'as barato que la contrataci\'on de c\'omputo o la compra de material dedicado.

Por su contra, la dificultad para llegar a un n\'umero importante de gente y los posibles
problemas que pueden aparecer en cuanto a la fiabilidad o correcci\'on de los datos
(aunque se pueden establecer mecanismos como la computaci\'on redundante
para asegurar la correcci\'on o la firma de c\'odigo para prevenir modificaciones maliciosas
del software), hacen que el m\'etodo no sea ideal.

En estos sistemas, los usuarios depositan su confianza en el proyecto, suponiendo que el software
que están ejecutando no daña sus dispositivos, el cómputo que se está realizando
servirá para cubrir la necesidad que se ha anunciado y que el sistema está blindado para 
que ningún usuario malintencionado lleve a cabo ningún tipo de actividad ilícita.

Sabiendo que la computación de algoritmos genéticos puede ser bastante lenta,
la computación voluntaria es un complemento a la computación de escritorio a la hora de obtener
más resultados, no teniendo por qué ser algo exclusivo, ya que la potencia de los procesadores
de hoy día es bastante grande.

El resto del trabajo se organiza de la forma siguiente \ldots


\section{Estado del arte}
Muchos son los proyectos que utilizan computación voluntaria 
para realizar sus cálculos. El primero de ellos fue ``Great Internet Mersenne Primer Search'' \cite{gimps},
en el año 1996, un sistema para calcular primos de Mersenne. Aunque el código de fuente es de dominio
público, no se considera software libre ya que los usuarios deben aceptar unas condiciones sobre la propiedad
intelectual de los resultados obtenidos, por lo que más tarde nacieron algunas versiones que son totalmente.

IBM cuenta con un programa de computación voluntaria con el que trata de alcanzar soluciones 
a enfermedades como el cáncer \cite{ibmwcg} y que cuenta con miles de voluntarios.

Especialmente conocido es el proyecto SETI@home, descrito en \cite{seti}, el cual funciona en la 
plataforma informática  ``Berkeley Open Infrastructure for Network Computing'' \cite{ries2012berkeley}. Este
sistema analiza señales de radio buscando vida extraterrestre. Dentro de la misma plataforma, podemos encontrar
otros muchos proyectos, como \cite{climate} mediante el cual se trata de predecir el clima. Esta plataforma es
libre y permite crear proyectos propios aunque tiene un gran problema: para que los usuarios participen,
es necesario que instalen un software (que se encargará de aprovechar el procesador de los voluntarios en 
aquellos momentos en los que no estén haciendo nada).

Existen algunos otros desarrollos como el que encontramos en \cite{sarmenta1998bayaniha} o \cite{jadif}.
Estos dos frameworks nos permiten crear nuestros experimentos de computación voluntaria utilizando el lenguaje
de programación Java. Al igual que en los casos anteriores, necesitaremos que los voluntarios descarguen e instalen
un programa (además de las propias dependencias de Java), lo que puede provocar que muchos usuarios no se sientan
atraídos a colaborar.

En cuanto a frameworks orientados a computación voluntaria con algoritmos evolutivos, ya en \cite{cole2010evolutionary}
podemos ver un análisis de algunas plataformas y comparaciones de rendimiento entre ellas. Sin embargo, NodIO añade
va más allá: permite ejecutar el cómputo desde el navegador al estar escrito el cliente en Javascript. Esto facilita
la participación en el experimento ya que cualquier dispositivo que sea capaz de ejecutar un navegador web va a poder 
ejecutarlo. Deriva de aquí otra ventaja: al solo necesitarse un navegador web, no es necesario que el usuario
se preocupe de instalar ningún software adicional en su máquina.


\section{NodIO}

NodIO \cite{nodio}, como se ha mencionado, es un marco de desarrollo crear experimentos de
computación voluntaria utilizando algoritmos evolutivos. En este caso, está pensado para ser desplegado en un
Plataforma como Servicio (Platform A a Service). Para el desarrollo de
los algoritmos se basa en un framework llamado NodEO \cite{nodeo},
desarrollado en NodeJS.

Gracias a esta implementación del lado cliente, se pueden lanzar experimentos y que los voluntarios los ejecuten
a través de un navegador (o cualquier sistema que ejecute el lenguaje Javascript
y que disponga de conexión a Internet).


\subsection{Funcionamiento}
A continuación se va a hablar del funcionamiento de NodIO, así como de sus distintas partes.

Este sistema cloud sigue un paradigma cliente - servidor:
\begin{itemize}
  \item Servidor: realiza la coordinación de los clientes, almacena los distintos chromosomas y
  el estado de los experimentos y reinicia el experimento cuando se ha encontrado la solución.
  El acceso y envío de los distintos chromosomas se hace a través de una interfaz API/REST.
  Las peticiones (que siguen el ciclo ``CRUD") utilizan el formato JSON. Está escrito en NodeJS.
  \item Cliente: procede con el cómputo. Hace peticiones asíncronas al servidor.
  En aquellos navegadores en los que esté permitido, se ejecuta utilizando ``Web Workers"
  (en caso contrario, se ejecuta una versión preparada para ello). Está escrito
  en Javascript, ya que se diseño pensando en que fuese ejecutado en navegadores aunque
  (gracias a que el servidor utiliza una API/REST), se podría escribir en cualquier otro
  lenguaje, siendo totalmente compatible con el actual servidor.
\end{itemize}

Teniendo clara esta separación, es hora de ver el papel que juegan cada uno de los elementos
dentro del algoritmo \ref{algoritmo}.

\begin{algorithm}[H]
  \caption{Algoritmo utilizado en NodIO para la realización de experimentos}
  \label{algoritmo}
  \begin{algorithmic}
    \State Inicio del $servidor$
    \State $numero\_secuencia \gets 0$
    \State $poblacion\_compartida \gets random[]$
    \State Se crea el archivo de log
    \ForAll{$clientes$}
       \State $cliente$ accede al link
       \State $servidor$ envía la página y los scripts a ejecutar
       \State $cliente$ renderiza la página
       \Loop
         \State $UUID \gets new\_UUID$
         \State $poblacion \gets generarPoblacion()$
         \Repeat
            \While{$poblaciones\_generadas\leq n$}
               \State $generarPoblacion()$
            \EndWhile
            \State El $chromosoma$ con mejor $fitness$ es enviado al $servidor$
            \If $Not mejor\_global(chromosoma)$
                \State $servidor$ envía un $chromosoma$ aleatorio de $poblacion\_compartida$
                \State $servidor$ envía el número actual de generación y el mejor $chromosoma$
                \State $cliente$ actualiza los gráficos
            \EndIf
         \Until{mejor-global(chromosoma)}
         \State $cliente$ actualiza los gráficos
         \State El experimento acaba
         \State El $numero\_secuencia \gets numero\_secuencia+1$ 
         \State $poblacion\_compartida \gets random[]$
         \EndLoop
      \EndFor

  \end{algorithmic}
\end{algorithm}


Para la creación de un nuevo exprimento necesitaremos modificar, al menos, dos ficheros: ``is\_solution.js'' 
-que se ejecuta en el servidor, decide si el choromosoma enviado por el cliente es una solución aceptable- y 
``trap.standalone.js'' -se ejecuta en el cliente y es donde se ejecutan los algoritmos evolutivos-. Dependiendo de 
las necesidades que tenga el experimento deseado, habrá que revisar
otros archivos para ajustar aquellos parámetros que se deseen -como NodIO cuenta con una licencia libre,
esto no es problema-. 

\subsection{Experimentos}
Algunos experimentos ya fueron hechos en \cite{nodio} para mostrar la velocidad de ejecución de los distintos
cómputos en Javascript frente a otros lenguajes. En este trabajo se ha procedido a realizar algunos experimentos
para mostrar, a pequeña escala, el beneficio que nos aporta la computación voluntaria en cuanto a rendimiento.

En un primer experimento, se ha comprobado el tiempo de ejecución en función del número de pestañas
que están ejecutando el cliente. La máquina que hace de servidor hace también las veces de cliente,
comenzando la ejecución de los clientes de forma síncrona. Como problema a resolver,
se ha utilizado el de resolver la función ``trap'', con unos valores de: número de traps, 24;
longitud del trap, 4; b, 2; caché, 32; y, tamaño de población, de 128. Se han escogido estos valores
para conseguir un experimento que sea relativamente sencillo, de forma que se pudiera medir
fácilmente el tiempo que tarda en resolverlo un solo voluntario. Estas pruebas se han hecho en un 
sistema operativo GNU/Linux (distribución ArchLinux con kernel 4.5.1) con un procesador i5-2410M CPU @ 
2.30GHz. El navegador utilizado ha sido la versión 50 de Chromium.

\begin{figure}[htbp]
\includegraphics[scale=0.6]{img/tiempo-pestanas}
\centering
\caption{Resultados obtenidos al medir el tiempo que se tarda en alcanzar una
solución en un mismo ordenador en función del número de pestañas abierto}
\label{tiempo-pestanas}
\end{figure}

En el experimento se han ido variando el número de pestañas abiertas y se ha ejecutado el experimento
varias veces -calculando una media ponderada para representar en \ref{tiempo-pestanas}-. 
Como podemos observar, cuando solo tenemos una pestaña abierta, el tiempo se
dispara (en torno a unos 3 minutos). En el caso de dos pestañas, el tiempo descenció hasta
un tiempo estimado de 53.22 segundos. En el resto de los casos, aunque sigue habiendo
diferencias de tiempo (unos 14.56, 10.11 y 7.46 segundos respectivamente), no es
tan notable como en los otros dos casos. Esto puede tener varias explicaciones: por un
lado al aumentar el número de pestañas, el poder computacional desciende (el
sistema operativo se ve con una carga de trabajo con la que tiene que lidiar).
Por otro, llegará un momento en el que no se podrá reducir más el tiempo
de ejecución por la propia naturaleza del problema.


Para el segundo experimento, se ha medido el tiempo que tarda en alcanzarse una solución
utilizando como clientes hasta tres dispositivos con la misma configuración hardware -teléfonos
móviles LG Bello II con procesador quad-core Cortex-A7 1.3GHz con Android versión 5.0.2 y navegador Chrome-.

En la figura \ref{tiempo-dispositivos} podemos ver los resultados.  Si comparamos con
la figura \ref{tiempo-pestanas}, es sencillo ver que existe simetría, aunque
en este nuevo caso los tiempos son algo mayores -que podemos achacar a un menor rendimiento
por parte del procesador del dispositivo móvil y a la existencia de una red entre
el servidor y los dispositivos, cuando antes se ejecutaba todo dentro de la misma
máquina-.

\begin{figure}[htbp]
\includegraphics[scale=0.6]{img/tiempo-dispositivos}
\centering
\caption{Resultados obtenidos al medir el tiempo que se tarda en alcanzar una
solución utilizando varios dispositivos con la misma configuración hardware y software}
\label{tiempo-dispositivos}
\end{figure}




\section{Conclusiones y trabajo futuro}


En cuanto a trabajos futuros, muchas son las ideas que se pueden desarrollar utilizando esta 
herramienta (o a partir de la misma). La idea más directa de todas es la realización de nuevos
experimentos, no tanto sobre la velocidad para alcanzar la solución a un problema dado como
para investigar sobre el comportamiento de los usuarios, es decir, una vez lanzado un experimento
tratar de conocer si los usuarios se sienten atraidos por la idea de participar en un
experimento -difundiendo un enlace al mismo a través de redes sociales- y, una vez que han iniciado
el experimento, cuánto tiempo participan. Dentro de esta línea, la idea de incluir técnicas 
relacionadas con ``ludificación'' -para atraer a los usuarios y hacer que estos se queden más tiempo
ejecutando los distintos experimentos- sería otra cuestión a resolver, junto con la internacionalización
de la aplicación -actualmente solo se encuentra disponible en inglés, por lo que al extenderlo
a otros idiomas, como el castellano, se llegaría a más gente-.Conseguir una mayor automatización en la creación
de los experimentos es un camino a tener en cuenta, facilitando que cualquiera pueda implementar
más sencillamente lo que necesite -proporcionando solo algunas plantillas donde rellenando unas pocas
líneas se tenga lo necesario para lanzar el experimento-. 


\bibliographystyle{splncs}
\bibliography{volunteer}

\end{document}
